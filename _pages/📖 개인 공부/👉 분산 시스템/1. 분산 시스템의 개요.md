---
title: "[#1] Distributed Systems Overview"
tags:
    - CS
    - Distributed Systems
    - Study
date: "2025-03-05"
thumbnail: "/assets/img/thumbnail/Distributed.png"
bookmark: true
---

데이터 엔지니어링을 본격적으로 공부하기 전에, 우리는 분산 시스템이라는 개념을 먼저 이해해야 합니다. 그리고 이 분산 시스템이 등장하게 된 배경을 이해하려면, 그보다 먼저 컴퓨터가 어떻게 발전해왔는지를 살펴보는 것이 좋습니다.

이번 글에서는 1930년대부터 1980년대까지, 컴퓨터가 어떻게 변화했는지 간단하지만 핵심적인 흐름을 중심으로 정리해보려 합니다. 오늘날 우리가 사용하는 고성능 컴퓨터와 데이터 시스템의 원형은, 사실 100년도 안 된 과거에서 시작되었죠.

## 💻 1. 컴퓨터의 역사와 진화 과정

### 💻 1.1. 1930년대: 손으로 계산하던 시대에서 '기계가 대신'하는 시대로
---
컴퓨터의 시작은 ‘사람이 직접 계산해야 했던 작업을 자동화하는 기계’였습니다. 당시에는 지금처럼 키보드와 모니터가 있는 것도 아니고, 마우스는커녕 화면조차 없었습니다.

***<span style="color:#00BFFF">▷ 대표적인 기계: Z3 컴퓨터 (1941)</span>***
1930년대 말부터 독일의 콘라드 추제가 개발한 Z3는 세계 최초의 프로그래머블 컴퓨터로 알려져 있습니다. 초기에는 이런 기계들이 전자식이 아니라 전기 기계식(relay-based)이었고, 하나의 문제를 풀기 위해 기계에 물리적으로 배선을 바꾸거나 작업을 수동으로 등록해야 했습니다.

***<span style="color:#00BFFF">▷ 어떤 작업을 했을까?</span>***
예를 들어, 복잡한 포탄 궤적을 계산하는 것처럼 많은 수학 연산이 필요한 군사적 작업에서 이런 기계는 유용하게 쓰였습니다. 사람이 종이에 계산하는 데 1시간 걸릴 걸, 기계가 몇 분만에 대신 처리해준 거죠.

<br>

### 💻 1.2. 1940년대: ENIAC과 폰 노이만 구조, 컴퓨터의 '설계도'가 바뀌다
---
1940년대에 들어서면서 컴퓨터의 구조는 큰 전환점을 맞이합니다. 바로 **폰 노이만 아키텍처(Von Neumann Architecture)**의 등장입니다.

***<span style="color:#00BFFF">▷ ENIAC (1945): 진짜 최초의 전자식 컴퓨터</span>***
미국에서 개발된 **ENIAC**은 세계 최초의 범용 전자식 컴퓨터였습니다. 하지만 ENIAC은 초기에는 ***‘프로그램을 저장할 수 없는 구조’*** 였습니다.. 매번 프로그램을 바꾸려면 배선을 다시 연결해야 했습니다.
이건 마치, 스마트폰 앱을 바꿀 때마다 회로를 납땜해야 하는 수준이었습니다.

***<span style="color:#00BFFF">▷ stored-program concept: 컴퓨터의 사고방식이 바뀌다</span>***
<img src="/assets/img/storedProgram.PNG" alt="storedProgram" />

> 출처 : https://cs.hofstra.edu/~cscvjc/Fall06/Slides/Sess10/img2.html

폰 노이만 구조는 프로그램도 데이터처럼 메모리에 저장해서 처리하는 방식을 제안했습니다. 이 구조 덕분에 컴퓨터는 훨씬 유연해졌고, ‘재프로그래밍’이 가능해졌습니다.
오늘날 거의 모든 컴퓨터는 이 구조를 따릅니다. CPU, 메모리, 입출력 장치로 나뉘고, 명령어를 메모리에 저장해서 순차적으로 실행하는 방식입니다.


### 💻 1.3. 1980년대: **개인용 컴퓨터(PC)**와 프로그래밍 언어의 대중화
컴퓨터는 이제 연구실에서 벗어나 일반 가정으로 들어오게 됩니다. 이 시기 가장 큰 변화는 IBM의 x86 아키텍처와 마이크로프로세서의 등장입니다.

***<span style="color:#00BFFF">▷ IBM PC (1981)와 x86 아키텍처</span>***
IBM이 발표한 IBM PC는 인텔의 8086 마이크로프로세서를 기반으로 했습니다.
이 구조는 오늘날의 데스크톱 PC에도 여전히 영향을 미치는 기반이죠.
x86 아키텍처는 CPU의 명령어 집합 구조를 의미하며, 소프트웨어와 하드웨어의 호환성을 높였습니다.

***<span style="color:#00BFFF">▷ 프로그래밍 언어의 발전</span>***
이러한 하드웨어 기반 위에서 어셈블리 언어, C 언어, Pascal 같은 고급 프로그래밍 언어가 발전했습니다.
어셈블리 언어는 기계어보다 인간 친화적인 명령어로, CPU 명령을 직접 제어할 수 있었습니다.
고급 언어는 사람이 읽고 쓰기 쉽게 구성되었고, 다양한 운영체제와 시스템에서 활용될 수 있었습니다.
이 시기 Apple II, Commodore 64 같은 컴퓨터가 대중화되면서, 어린 시절부터 프로그래밍을 배우는 세대가 등장했습니다.
오늘날의 많은 개발자들이 이때 컴퓨터를 접하며 입문했다고 합니다.

### 💻 1.4. 원격 프로시저 호출(Remote Procedure Call, RPC)의 등장

> 컴퓨터의 빠른 처리 속도와 네트워크의 가능성

컴퓨터는 인간보다 훨씬 빠르게 명령어를 처리할 수 있습니다. 그렇기에 우리가 원하는 작업을 컴퓨터가 대신 처리해주길 원한다면, 명령어만 제대로 입력해주면 됩니다.

그렇다면 한 가지 의문이 생깁니다. ***"굳이 내가 사용하는 컴퓨터에서만 명령어를 처리해야 할까?"***
만약 물리적인 제약 없이, 다른 컴퓨터의 프로그램도 내가 마치 내 컴퓨터에서 실행하는 것처럼 사용할 수 있다면, 훨씬 더 많은 사람과 시스템이 효율적으로 작업할 수 있지 않을까요?

이러한 문제의식에서 출발한 개념이 바로 RPC(Remote Procedure Call) 입니다.

> RPC란 무엇인가?

Remote Procedure Call은 말 그대로, "원격에 있는 프로시저(함수)를 호출한다"는 개념입니다.
이것은 마치 같은 프로그램 안에 있는 함수를 호출하는 것처럼, 네트워크를 통해 다른 컴퓨터에 있는 함수도 호출할 수 있게 해줍니다.

```java
// 일반 함수 호출 예시
int result = add(3, 5); 

// 실제는 네트워크를 통해 원격 서버에 있는 'add' 함수를 호출
// 하지만 프로그래머는 마치 로컬 함수처럼 사용
```

프로그래머는 이 호출이 로컬인지 원격인지 신경 쓸 필요 없이, 추상화된 인터페이스를 통해 사용합니다.

RPC는 1980년대에 본격적으로 실용화되기 시작했습니다. 특히 Sun Microsystems는 1984년에 **ONC RPC(Open Network Computing RPC)**를 유닉스 시스템에 구현하며 널리 확산시켰습니다.
이 시기에 클라이언트-서버 아키텍처가 정착됩니다.

> 클라이언트(Client): 요청(Request)을 보내는 측. 예: 웹 브라우저
> 서버(Server): 요청을 받아 응답(Response)을 반환하는 측. 예: 웹 서버

RPC는 이 구조에서 클라이언트가 서버의 함수나 프로시저를 호출하는 방식으로 사용됩니다. 이때, 호출은 request-response protocol을 따릅니다.

### 💻 1.5. 데이터베이스(Database)의 등장

컴퓨터가 단순 계산 이상을 해내게 되면서, 사람들은 “더 많은 데이터를 더 빠르게 처리할 수는 없을까?”라는 질문을 던지기 시작했습니다.
특히 네트워크를 통해 여러 컴퓨터가 연결되고, 원격으로 프로그램을 호출할 수 있게 되면서, 한 곳(서버)에 데이터를 모아두고 여러 사람이 동시에 처리하는 환경이 가능해졌습니다.

이러한 배경 속에서 태어난 것이 바로 **데이터베이스 시스템(Database System)**입니다.

> Relational Database의 등장 (1970년대)

1970년대, IBM의 연구원이었던 E.F. Codd는 **관계형 데이터 모델(Relational Model)**을 제안합니다. 이 모델은 오늘날 우리가 흔히 보는 테이블 형태의 데이터 저장 방식의 기반이 되었고, 이후에 **RDBMS(Relational Database Management System)**로 발전합니다.

 - 데이터를 테이블(행과 열)로 구성
 - SQL을 통해 데이터를 검색, 삽입, 수정, 삭제할 수 있음

이후 IBM은 1983년, 세계 최초의 상용 관계형 데이터베이스인 IBM DB2를 출시하며 데이터베이스 시장의 문을 엽니다.

> SQL의 등장과 데이터 처리의 표준화

SQL(Structured Query Language)은 데이터를 조작하고 관리하기 위한 언어입니다.
1986년 ANSI에 의해 표준화되며, 전 세계적으로 관계형 데이터베이스를 사용하는 주요 수단이 되었죠.

```sql
-- 예: 고객 테이블에서 이름이 '홍길동'인 고객 조회
SELECT * FROM customers WHERE name = '홍길동';
```

이후 Oracle, MySQL, PostgreSQL 등 다양한 RDBMS가 등장하며, 정형화된 대량 데이터 처리가 가능해졌습니다.

> 처리 성능은 Scale-Up 중심

이 시기 데이터베이스는 **하드웨어 자체의 성능을 늘리는 방식(Scale-Up)**으로 처리량을 확장했습니다.
CPU, 메모리, 디스크 등을 업그레이드하는 식이었죠.
하지만 이 방식은 한계도 분명했습니다. 비용이 많이 들고, 일정 이상으로는 확장이 어렵기 때문입니다.

### 1.6. 3-Tier Architecture 의 등장

초창기 웹 서비스는 단순했다. 모든 기능을 하나의 서버에서 처리하는 모놀리식(Monolithic) 구조가 일반적이었다. 예를 들어 사용자의 요청, 로직 처리, 데이터 저장 모두를 하나의 서버가 전담했다. 이 구조는 초기에는 효율적일 수 있었지만, 다음과 같은 문제가 있었다:

 - 사용자 수 증가 시 처리 성능 저하
 - 모든 기능이 한 곳에 몰려 유지보수 어려움
 - 확장이 어려움 (부분 확장이 불가, 전체 서버 업그레이드 필요)

이러한 문제를 해결하기 위해 등장한 것이 ***3-Tier Architecture***이다.
각 기능을 역할별로 나누고, 계층 간 통신을 통해 전체 시스템을 보다 유연하고 효율적으로 설계할 수 있도록 했다.

1990년대 중반, 클라이언트-서버 구조가 진화하면서 **3-Tier Architecture(3계층 아키텍처)**가 등장했다. 이는 다음과 같은 세 가지 계층으로 구성된다:

✅ 1. Presentation Tier (프레젠테이션 계층)
사용자 인터페이스(UI)를 담당하며, 사용자와 직접 소통하는 웹 화면으로 구성된다.

✅ 2. Application Tier (로직 계층)
비즈니스 로직을 수행하는 핵심 계층으로, 클라이언트의 요청을 처리하고 데이터베이스와 상호작용한다.

✅ 3. Data Tier (데이터 계층)
데이터 저장 및 검색을 담당하는 계층으로, 실제 정보를 저장하는 DBMS가 이 역할을 수행한다.

이로써 기능별로 서버 역할을 분리하여, 관심사의 분리를 달성하고, 유지보수 용이성과 확장성을 확보하였다.
또한 각 계층의 독립적인 배포도 가능해졌으며, RPC 와 전문 DBMS 의 활용으로 계층 간 통신의 효율성도 증가하였다.

## 1.7. Web-WAS-DB 구조의 등장

3-Tier Architecture가 개념적으로 정립된 이후, 이를 실질적으로 웹 환경에서 구현한 구조가 바로 Web-WAS-DB 구조이다.

이 구조는 다음과 같은 세 가지 주요 계층으로 구성된다:

✅ 1. Web Server (웹 서버)
사용자의 요청을 가장 먼저 받는 계층으로, 정적인 콘텐츠(HTML, CSS, JS, 이미지 등)에 대한 처리를 담당한다. 웹 서버는 요청이 단순할 경우 직접 응답을 반환하고, 복잡한 로직 처리가 필요한 요청은 WAS 계층으로 전달한다. 대표적인 기술로는 Apache, Nginx 등이 있다.

✅ 2. WAS (Web Application Server, 웹 애플리케이션 서버)
비즈니스 로직을 처리하는 계층이다. 사용자의 요청 중 정적인 처리가 아닌 경우, 예를 들어 로그인, 데이터 조회, 결제 등의 요청은 이 계층에서 로직을 수행한다. 필요 시 DB와 통신하여 데이터를 가져오고, 처리 결과를 사용자에게 전달한다. Tomcat, Spring Boot, JBoss 등이 여기에 해당한다.

✅ 3. Database (데이터베이스 서버)
데이터 저장과 검색을 전담하는 계층이다. 사용자 정보, 상품 정보, 로그 기록 등 영속적인 데이터는 이 계층에서 관리된다. MySQL, PostgreSQL, Oracle, MongoDB 등 다양한 RDBMS/NoSQL 시스템이 여기에 속한다.

웹 서비스를 분석해보면, 전체 요청의 약 90% 이상이 정적인 데이터에 대한 요청이었다. 즉, 변하지 않는 정보(예: 공지사항, 게시글 목록, 이미지 등)에 대한 요청이 대부분이었다. 그런데 이러한 요청도 WAS와 DB를 거쳐 처리하면 비효율적 자원 소모가 발생한다.

이러한 문제를 해결하기 위해 Web-WAS-DB 구조는 다음과 같은 전략을 사용했다:

 - 정적인 요청은 웹 서버에서 빠르게 응답하도록 처리

 - WAS는 실제 로직 처리가 필요한 요청에만 집중

 - DB는 필요한 데이터에 대해서만 조회 및 저장을 수행

또한, 정적 응답을 캐싱(Cache) 해두고, 매번 동일한 요청이 들어와도 빠르게 응답할 수 있도록 하여 전체 시스템의 성능을 비약적으로 향상시켰다.
---
title: "[#2] 📘 하둡의 핵심 구성요소와 실습 과정"
tags:
    - Apache
    - Hadoop
    - Study
date: "2025-02-15"
thumbnail: "/assets/img/thumbnail/hadoop_basic_2.png"
bookmark: true
---

저번 포스팅에서는, 하둡이 어떻게 등장했는지를 공부하고 정리해봤습니다.

[📘 분산 시스템의 이해와 하둡의 등장 배경](https://jeondaehong.github.io/%F0%9F%93%96%20%EA%B0%9C%EC%9D%B8%20%EA%B3%B5%EB%B6%80/%F0%9F%91%89%20Apache%20Hadoop/1.%20%EB%B6%84%EC%82%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EC%9D%B4%ED%95%B4%EC%99%80%20%ED%95%98%EB%91%A1%EC%9D%98%20%EB%93%B1%EC%9E%A5%20%EB%B0%B0%EA%B2%BD.html)

<br>

# 🐘 1. HDFS

HDFS 는 `Hadoop` 의 ***핵심 아키텍처 중 하나***입니다.
HDFS 의 아키텍처에도 따로 **Block File System, NameNode, DataNode** 등이 있습니다.
HDFS 가 무엇인지를 본격적으로 알아보기 전에, **HDFS** 가 어떤 ***철학과 목표***를 가지고 만들어졌는지, 그 특징은 무엇인지를 간단하게 공부하고 넘어가겠습니다.

<span style="text-decoration: underline; text-decoration-color: red;">**① HDFS 는 하드웨어 장애에 대처할 수 있어야 합니다.**</span>
HDFS를 구성하는 분산 서버에는 다양한 장애가 발생할 수 있습니다.
예를 들면 하드디스크에 오류가 생겨서 데이터 저장에 실패하는 경우, 디스크 복구가 불가능해 데이터가 유실되는 경우, 네트워크 장애가 생겨 특정 분산 서버에 네트워크 접근이 안되는 경우 등이 있을 수 있습니다.
HDFS는 이런 장애를 빠른 시간에 감지하고 대처할 수 있게 설계되어 있습니다.
HDFS에 데이터를 저장하면, 복제본도 함께 저장되어 데이터 유실을 방지하며, 분산 서버 사이에는 주기적으로 health check 를 통해 빠른 시간에 장애를 감지하고 대처할 수 있게 됩니다.


<span style="text-decoration: underline; text-decoration-color: red;">**② HDFS 는 Streaming 식 데이터 접근에 최적화 되어있습니다.**</span>
HDFS는 사용자 요청을 빠르게 처리하는 것보다 동일 시간 내에 더 많은 데이터를 안정적으로 처리하는 데 중점을 둡니다.
따라서 중간부터 읽고, 쓰는 Random Access 방식보다는 처음부터 순차적으로 읽어가는 Streaming 방식에 최적화되어 있습니다.
가끔 이 Streaming 방식이 카프카처럼 실시한 데이터 스트리밍과 헷갈릴 수 있는데, 그런 스트리밍을 의미하는것이 아니라, 처음부터 끝까지 순차적으로 데이터를 읽는데에 특화되었다는 의미입니다.
이런 방식으로 인해 사용자와 상호작용이 많은 트랜잭션 기반 서비스(예: 인터넷 뱅킹, 쇼핑몰 등)보다는 대규모 데이터를 일괄 처리하는 배치 처리(batch processing)에 더 적합합니다.

<span style="text-decoration: underline; text-decoration-color: red;">**③ HDFS 는 대용량 데이터셋 처리에 유리합니다.**</span>
HDFS는 하나의 파일이 수 기가바이트(GB)에서 수 테라바이트(TB)에 이르는 크기로 저장될 수 있도록 설계되어 있습니다.
이를 통해 높은 **데이터 전송 대역폭(bandwidth)**을 지원하며, 수백 대의 노드로 구성된 클러스터를 효율적으로 운영할 수 있습니다. HDFS는 단일 인스턴스에서 수천만 개 이상의 파일을 관리할 수 있습니다.
여기서 말하는 데이터 전송 대역폭은, 한 번에 얼마나 많은 데이터를 빠르게 보낼 수 있는가를 의미합니다.

<span style="text-decoration: underline; text-decoration-color: red;">**④ HDFS 는 심플하고, 일관성이 있습니다.**</span>
데이터 무결성을 유지하기 위해, HDFS는 한 번 저장한 데이터는 수정하지 않고 읽기만 가능한 모델을 따릅니다. 이를 write-once-read-many 모델이라 하며, 데이터가 저장된 후 변경되지 않음으로써 무결성을 보장합니다.
기존에는 저장 후 수정이 전혀 불가능했으나, 현재는 파일의 끝부분에 데이터를 ***append*** 하는 방식은 지원됩니다.
이러한 단순한 일관성 모델은 데이터 처리량을 높이며, 특히 `MapReduce`와 같은 처리 방식에 큰 장점을 제공합니다.

<span style="text-decoration: underline; text-decoration-color: red;">**⑤ HDFS 는 데이터를 직접 옮기지 않고, 데이터가 위치한 노드에서 연산을 실행합니다.**</span>
컴퓨팅 처리를 위해 데이터를 이동시키는 것보다, 연산 작업을 데이터가 위치한 곳으로 이동시키는 것이 비용과 성능 면에서 더 유리합니다. 이는 특히 데이터 양이 방대할수록 더욱 중요합니다. 네트워크 혼잡을 줄이고 시스템 전체의 처리량을 높일 수 있기 때문입니다.
HDFS는 이를 고려하여, 데이터가 위치한 노드에서 연산이 실행되도록 처리합니다. 이러한 접근 방식은 **전체 클러스터의 효율성**을 높이는 데 크게 기여합니다.

<span style="text-decoration: underline; text-decoration-color: red;">**⑥ HDFS 는 여러 플랫폼 간의 이식성을 가지고 있습니다.**</span>
HDFS는 다양한 하드웨어 및 운영체제 환경에서 동일한 기능을 제공할 수 있도록 설계되어 있습니다. 인텔이나 AMD 칩이 설치된 서버에서도 문제없이 동작하며, CentOS나 Red Hat Linux와 같은 다양한 리눅스 배포판에서도 동일하게 사용할 수 있습니다.
이는 HDFS의 서버 코드가 Java 언어로 구현되어 있기 때문에 가능한 일입니다. Java의 플랫폼 독립성이 HDFS의 높은 이식성과 호환성을 보장해 줍니다. 이러한 특성은 HDFS가 대용량 데이터 저장 플랫폼으로 널리 채택되는 중요한 이유 중 하나입니다.

## 🐘 1.1. Block File System
---
HDFS는 블록 구조로 동작하는 분산 파일 시스템입니다.
HDFS에 저장되는 모든 파일은 일정 크기의 블록 단위로 분할되어 여러 서버에 분산 저장됩니다.
기본 블록 크기는 128MB이며, 설정을 통해 조정이 가능합니다. ( 하둡 V1 에서는 64MB였습니다. )
이러한 블록 기반 구조 덕분에 로컬 디스크의 제한을 넘어서 페타바이트(PB) 단위의 대용량 데이터 저장이 가능하게 됩니다.

### ✅ HDFS에서 파일과 블록은 다음과 같은 규칙을 따릅니다

| 구분                     | 설명                                                                 | 예시                                                                                 |
|------------------------|----------------------------------------------------------------------|-------------------------------------------------------------------------------------|
| 파일과 블록 관계            | 하나의 파일은 하나 또는 여러 개의 블록에 저장됩니다.                                  | 파일 A → 블록 1개 또는 여러 개로 분할 저장                                                      |
| 블록 관리                 | 어떤 파일이 어떤 블록에 저장되는지는 Namenode가 메모리 내 메타데이터로 관리합니다.           | -                                                                                   |
| 블록 독립성               | 하나의 블록에는 여러 파일이 저장되지 않으며, **항상 단일 파일 전용**입니다.                  | 블록 B에는 오직 파일 A 일부만 저장 가능                                                       |
| 블록 분할                | 파일 크기가 블록 크기를 초과하면, 파일은 여러 블록에 나뉘어 저장됩니다.                      | 파일 크기: 128MB + 10byte → 블록 1: 128MB, 블록 2: 10byte                                |
| 블록 크기 미만의 파일        | 파일 크기가 블록보다 작아도 전체 블록을 할당받지만, **사용된 용량만 실제 디스크에 저장**됩니다.     | 파일 크기: 1MB, 블록 크기: 128MB → 블록은 1MB만 사용                                          |
| 블록이 나눠떨어지지 않는 경우 | 파일이 블록 크기로 나눠떨어지지 않으면, 마지막 블록은 남은 크기만큼 점유합니다.                | 파일 크기: 129MB, 블록 크기: 128MB → 블록 1: 128MB, 블록 2: 1MB                             |
| 디스크 점유 공간            | 실제 디스크에서 점유하는 공간은 블록 전체가 아닌, **파일의 실제 크기**만큼입니다.              | 블록 크기: 128MB, 파일 크기: 1MB → 디스크 사용: 1MB                                           |


### ✅ 이렇게 Block System 을 유지하므로써 다음과 같은 장점을 가질 수 있게 되었습니다.




## 🐘 1.2. NameNode 와 DataNode
---


## 🐘 1.3. Secondary NameNode
---


## 🐘 1.4. Read 와 Write 시 내부에서 벌어지는 일
---

<br>
<br>
<div align="center">◈</div>
<br>

# 🐘 2. Hadoop H/A 클러스터

## 🐘 2.1. 클러스터 구성 위해 잠시 짚어갈 Zookeeper
---


## 🐘 2.2. Quorum Journal Nodes H/A
---


## 🐘 2.3. Shared Storage H/A
---


## 🐘 2.4. Automatic Failover
---


## 🐘 2.5. Observer Name Node ( ONN )
---

<br>
<br>
<div align="center">◈</div>
<br>

# 🐘 3. Eraser Coding

## 🐘 3.1. Software Eraser Coding
---

## 🐘 3.2. Hardware Eraser Coding
---

## 🐘 3.3. 하둡에서의 Eraser Coding
---

<br>
<br>
<div align="center">◈</div>
<br>

# 🐘 4. YARN

## 🐘 4.1. YARN 이란
---

## 🐘 4.2. YARN 아키텍처
---

### 🐘 4.2.1. 기본 아키텍처

### 🐘 4.2.2. Resource Mananger

### 🐘 4.2.3. Node Manager


## 🐘 4.3. YARN 의 작업 흐름
---

### 🐘 4.3.1. High Level Workflow

### 🐘 4.3.2. Application 실행 요청

### 🐘 4.3.3. Application Master 실행 요청

### 🐘 4.3.4. Application Master 등록

### 🐘 4.3.5. 컨테이너 실행

### 🐘 4.3.6. Application Master 종료

### 🐘 4.3.7. Auxiliary Service


## 🐘 4.4. Fair Call Queue 와 FIFO Queue
---

## 🐘 4.5. YARN 실습
---

<br>
<br>
<div align="center">◈</div>
<br>

# 🐘 5. Map Reduce

## 🐘 5.1. Map Reduce 란
---

## 🐘 5.2. Map Reduce 기능과 프로그래밍
---

## 🐘 5.3. Map Reduce 실습
---

## 🐘 5.4. Map Reduce 의 한계
---

## 🐘 5.5. Cascading
---

<br>
<br>
<div align="center">◈</div>
<br>

# ✏️ 결론

<br>
<br>
<div align="center">◈</div>
<br>

# 📚 공부 참고 자료
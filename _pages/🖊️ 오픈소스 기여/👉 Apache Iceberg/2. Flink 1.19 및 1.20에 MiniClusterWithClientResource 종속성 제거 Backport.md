---
title: "[#7] 📘 Flink 1.19 및 1.20에 MiniClusterWithClientResource 종속성 제거 Backport"
tags:
    - OpenSource PR
    - Iceberg
    - Flink
date: "2025-05-23"
thumbnail: "/assets/img/thumbnail/OpenSource_3.png"
bookmark: true
---

# ✏️ 1. 서론
---

이전 포스팅에서 소개한 것처럼, Iceberg Flink Catalog v2.0에서 `MiniClusterWithClientResource` 종속성 제거에 성공했습니다. 이에 따라 해당 이슈의 연장선이자 메인테이너의 요청에 따라, 동일한 변경 사항을 Flink 1.19와 1.20 버전에도 백포팅하기로 했습니다.
(현재 Iceberg는 1.9.1 버전을 사용 중이며, Flink Catalog는 1.19, 1.20, 그리고 2.0 버전을 지원합니다.)

이번 작업은 이전 포스팅인 [📘 Iceberg Flink Catalog v2.0 MiniClusterWithClientResource 종속성 제거](https://jeondaehong.github.io/%F0%9F%96%8A%EF%B8%8F%20%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%20%EA%B8%B0%EC%97%AC/%F0%9F%91%89%20Apache%20Iceberg/1.%20Iceberg%20Flink%20Catalog%20v2.0%20MiniClusterWithClientResource%20%EC%A2%85%EC%86%8D%EC%84%B1%20%EC%A0%9C%EA%B1%B0.html) 의 연장선이자, 유사한 내용이 많아, 비교적 짧게 정리해보려 합니다.

<br>
<div align="center">◈</div>
<br>

# ✏️ 2. 본론

## ‍💻 2.1. PR: MiniClusterWithClientResource 종속성 제거 Backporting
---

이번 작업 역시 이전 PR의 연장선에 있기 때문에, 이슈 선정 과정에 대한 설명은 생략하였습니다.
따라서 이번 포스팅에서는 곧바로 PR 과정부터 다루겠습니다.

이슈 선정 배경이나 PR 전체 흐름이 궁금하신 분들은 이전 포스팅인 [📘 Iceberg Flink Catalog v2.0 MiniClusterWithClientResource 종속성 제거](https://jeondaehong.github.io/%F0%9F%96%8A%EF%B8%8F%20%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%20%EA%B8%B0%EC%97%AC/%F0%9F%91%89%20Apache%20Iceberg/1.%20Iceberg%20Flink%20Catalog%20v2.0%20MiniClusterWithClientResource%20%EC%A2%85%EC%86%8D%EC%84%B1%20%EC%A0%9C%EA%B1%B0.html) 을 참고해주시기 바랍니다.

### 1️⃣ COMMIT : v1.19 Backporting


<br>
### 2️⃣ COMMIT : v1.20 Backporting


<br>
### 3️⃣ COMMIT : MiniClusterWithClientResource 종속성 제거

마지막이 드디어, 이번 PR 의 꽃인, TestIcebergSourceFailover 클래스에서 MiniClusterWithClientResource 종속성을 제거하는 것이었습니다.

이 부분에 대한 설명은 조금 길어질 수 있으니, 먼저 ASIS 코드를 보겠습니다.

**Before:**
```java
import org.apache.flink.test.util.MiniClusterWithClientResource;
import org.apache.flink.util.function.ThrowingConsumer;

// ...

@Test
public void testBoundedWithTaskManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testBoundedIcebergSource(FailoverType.TM, miniCluster));
}

@Test
public void testBoundedWithJobManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testBoundedIcebergSource(FailoverType.JM, miniCluster));
}
  
// ...

@Test
public void testContinuousWithTaskManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testContinuousIcebergSource(FailoverType.TM, miniCluster));
}

@Test
public void testContinuousWithJobManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testContinuousIcebergSource(FailoverType.JM, miniCluster));
}

// ...

private static void runTestWithNewMiniCluster(ThrowingConsumer<MiniCluster, Exception> testMethod) throws Exception {
    MiniClusterWithClientResource miniCluster = null;
    try {
        miniCluster = new MiniClusterWithClientResource(MINI_CLUSTER_RESOURCE_CONFIG);
	    miniCluster.before();
        testMethod.accept(miniCluster.getMiniCluster());
    } finally {
        if (miniCluster != null) {
          miniCluster.after();
        }
    }
}

```

먼저, JUnit 5에서는 @BeforeAll, @AfterAll, @BeforeEach, @AfterEach를 사용해 리소스 생명 주기를 다루는 게 일반적입니다. 하지만 해당 코드는 테스트마다 miniCluster.before() / after()를 수동으로 호출합니다. 이부분이 JUnit 4 스타일이라고 할 수 있습니다.

또한, `MiniClusterWithClientResource` 는 보통 JUnit4의 `ExternalResource` 를 상속해서 구현합니다. JUnit4에서는 리소스 초기화와 정리를 위해 `@Rule` 어노테이션을 통해 `ExternalResource` 를 사용합니다. 이는, Flink 개발 초기 시점과 JUnit5 도입 시점의 시기적 차이 때문에, 기존에 잘 만들어진 테스트 유틸리티들이 JUnit4 스타일로 많이 남아 있습니다. 이런 이유 때문에, 사실 완전히 Junit4 를 당장 걷어내는 것이 어렵다고 판단한 거 같습니다. 즉, Flink 의 Minicluster 를 활용한 테스트코드 자체가 완전히 JUnit5로 완전히 마이그레이션되지 않은 상태이기 때문에, Iceberg 에도 당장 적용하기 어렵다는 것으로 생각됩니다.

계속 이어서 설명하자면, 여기서는 테스트가 실행될 때마다 MiniClusterWithClientResource 인스턴스를 직접 생성하고, 수동으로 before()와 after()를 호출해서 클러스터 시작과 종료를 명시적으로 제어하고 있습니다. 테스트 메서드들은 MiniCluster를 직접 파라미터로 받지 않고, 람다 ThrowingConsumer에 넘겨서 간접적으로 처리합니다. 즉, 리소스 관리를 테스트 코드 내부에서 직접 제어하는 형태입니다. 보통 이런 방식은 JUnit4에서 @Rule 같은 자동 리소스 관리가 없거나 커스텀 상황에서 쓰입니다.

그래서 아래와 같은 코드로 수정을 진행하였습니다.

**After:**
```java
import org.apache.flink.test.junit5.InjectMiniCluster;

// ...

@Test
public void testBoundedWithTaskManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testBoundedIcebergSource(FailoverType.TM, miniCluster);
}
  
@Test
public void testBoundedWithJobManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testBoundedIcebergSource(FailoverType.JM, miniCluster);
}
  
// ...
  
@Test
public void testContinuousWithTaskManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testContinuousIcebergSource(FailoverType.TM, miniCluster);
}

@Test
public void testContinuousWithJobManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testContinuousIcebergSource(FailoverType.JM, miniCluster);
}

```

중점은, 리소스 관리면에서, MiniClusterWithClientResource 수동 생성 및 before()/after() 호출 하는 부분을 @InjectMiniCluster를 통해 자동으로 주입 및 관리를 할 수 있게끔 변경했다는 부분입니다.

그리고 테스트 코드 작성 시, 람다 방식으로 테스트 실행, 리소스 관리를 직접 제어하는 방식에서 테스트 메서드 파라미터로 리소스 주입 받아 사용하도록 변경하였고,

ExternalResource 기반 (JUnit4 Rule) 방식에서 ParameterResolver 또는 Extension 기반 (JUnit5) 방식으로 변경하였다는 점이 있겠습니다.

이러한 방식에 MainTainer 들은 토론을 하였고, 괜찮은 방식이라는 결론에 다다르게 됩니다.

그리고, 다른 컨트리뷰터들 역시, 괜찮다는 리뷰를 달아주었습니다.

<img src="/assets/img/apache-iceberg-issue_review4.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<br>
### 🔧 MiniCluster 주입 후 실행 오류 발생 및 수동 생명주기 관리 코드 추가

그러나, 이부분에 대하여 처음에는 CI 테스트에서 문제가 발생하였습니다.

<img src="/assets/img/apache-iceberg-issue_review1.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<img src="/assets/img/apache-iceberg-issue_review2.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<img src="/assets/img/apache-iceberg-issue_review3.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

테스트가 120초 안에 끝나지 않고 Timeout으로 실패하는 문제가 발생한 것입니다.

@InjectMiniCluster를 통해 MiniCluster를 테스트 메서드에 주입받았지만 주입만 된 상태이지, 명시적으로 start()를 호출하지 않으면 MiniCluster가 실행되지 않았던 것으로 보입니다. 결국 테스트 로직에서 MiniCluster를 사용하려 했을 때, 클러스터가 "비활성 상태"이므로, 작업이 시작되지 않거나, 실행 중 hang 이 발생한 것으로 보입니다.

좀 더 원인을 찾아보니. JUnit5의 확장 모델에서는 @Inject... 같은 어노테이션으로 객체 주입은 가능하지만, 해당 객체의 생명주기(start/stop)는 자동으로 보장되지 않을 수 있다고 합니다. 또한 MiniCluster는 명시적으로 .start() 호출이 필요하고, 주입은 단순히 생성만 해주는 것이며, 실행은 별도 단계라는 원인을 찾을 수 있었습니다.

결과적으로 테스트가 MiniCluster에 작업을 제출하려 했지만, MiniCluster가 시작되지 않았고, 이는 테스트 timeout (120초) 초과로 실패까지 이어지게 된 것입니다.

**그래서 TestIcebergSourceFailover 클래스에 아래와 같은 코드를 추가 커밋하였습니다.**

**Add Code:**
```
import org.junit.jupiter.api.AfterEach; // AfterEach 추가

@BeforeEach
protected void startMiniCluster(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    if (!miniCluster.isRunning()) {
      miniCluster.start();
    }
}

@AfterEach
protected void stopMiniCluster(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    miniCluster.close();
}
```

@BeforeEach와 @AfterEach를 통해 MiniCluster의 시작과 종료를 명시적으로 제어함으로써, 테스트 실행 시 필요한 Flink 클러스터 환경이 정상적으로 초기화되고 정리될 수 있게 하였습니다.

그리고 그 결과, 최종적으로는 Iceberg 에 PR Merge 를 성공하여, Apache 재단의 Iceberg 프로젝트에 기여할 수 있었고, Contributor 가 될 수 있었습니다.

<br>
> 👉 My PR: [Iceberg Flink Catalog v2.0 Remove the MiniClusterWithClientResource dependency](https://github.com/apache/iceberg/pull/13021#issuecomment-2903837698)

<br>
<img src="/assets/img/apache-iceberg-contributor.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<img src="/assets/img/apache-iceberg-contributor2.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<br>
### 🍹 Local Test 및 CI 통과를 위한 절차 안내
처음 Iceberg 프로젝트에 기여하면서 가장 헷갈렸던 부분 중 하나가, 로컬 테스트와 CI 통과 방식이었습니다.

혹시 저처럼 Iceberg에 기여하고자 하는 분들이 계시다면, 아래 절차를 참고하시면 도움이 될 것입니다.

**✅ 코드 스타일 정리: spotlessApply**
Iceberg는 Spotless를 사용하여 코드 포맷팅을 검사합니다. 따라서 PR을 생성하기 전 반드시 아래 명령어를 실행하여 코드 스타일을 자동으로 정리해야 합니다:

```bash
./gradlew :iceberg-flink:iceberg-flink-2.0:spotlessApply
```
> 이 명령어는 Java 코드의 정해진 스타일 가이드에 맞게 들여쓰기, 정렬, 공백 등을 자동으로 수정해줍니다. 이를 적용하지 않으면 CI에서 spotlessCheck 단계에서 실패하게 됩니다.

<br>
**✅ 로컬 테스트 수행: test --stacktrace**
CI에 올리기 전에, 로컬 환경에서 먼저 유닛 테스트를 실행하여 이상이 없는지 확인해야 합니다:

```bash
./gradlew :iceberg-flink:iceberg-flink-2.0:test --stacktrace
```
> --stacktrace 옵션은 만약 테스트 실패 시 상세한 오류 메시지를 확인하는 데 도움이 됩니다.
> 테스트를 통과하지 못하면 CI 단계에서도 동일하게 실패하므로, 로컬에서 반드시 먼저 확인하는 것이 좋습니다.

참고로, 저는 flink 2.0 에 대하여 테스트를 진행하는 것이기 때문에 위와 같이 하였습니다.
`./gradlew projects` 를 통하여 테스트가 가능한 프로젝트 목록을 확인한 후에, 원하는 프로젝트를 가지고 진행해주면 되겠습니다.

<br>
<div align="center">◈</div>
<br>


# ✏️ 3. 결론
---

이번 기여를 통해 기술적인 역량뿐만 아니라, 오픈소스 프로젝트에서의 커뮤니케이션의 중요성을 깊이 체감할 수 있었습니다.
단순히 코드를 작성하고 제출하는 것을 넘어, Maintainer 및 다른 기여자들과의 지속적인 소통, 피드백 수용, 그리고 협업 방향 조율이 얼마나 중요한지 직접 경험하게 되었습니다.

특히 이슈를 공유하고, 작업 계획을 명확히 전달하며, 리뷰어의 피드백을 빠르게 반영하는 과정을 통해 오픈소스 생태계의 협업 문화가 신뢰와 효율을 만들어내는 구조임을 배웠습니다.

첫 번째 PR을 통해 긍정적인 피드백을 받은 뒤, Maintainer로부터 요청받았던 Flink 1.20 및 1.19 버전에 대한 backport 작업 역시 빠르게 진행하고 싶다는 동기부여가 생겼고, 기술적 기여뿐 아니라 프로젝트 요구에 신속히 대응하는 태도의 중요성도 느꼈습니다.

또한, 오픈소스 멘토링에서 운영진 역할을 맡아 저의 기여를 하면서 동시에 많은 멘티들이 오픈소스에 도전하는 과정을 지켜보고, 그분들께 답글로 방향성을 제시하는 경험은 저 자신의 성장에도 큰 자극이 되었습니다.
비록 오늘 포스팅에서는 멘토링 내용이 자세히 다뤄지지 않았지만, 저는 앞으로도 이 멘토링 활동과 오픈소스 기여를 꾸준히 이어갈 것이며, 우리나라에 올바르고 건강한 오픈소스 기여 문화가 자리잡도록 노력하는 1세대가 되고자 합니다.

앞으로도 단순한 코드 제공을 넘어, 신뢰를 바탕으로 커뮤니케이션하고, 프로젝트에 실질적인 가치를 더하는 기여자가 되기 위해 꾸준히 노력하겠습니다.
---
title: "[#7] 📘 Flink 1.19 및 1.20에 MiniClusterWithClientResource 종속성 제거 Backport"
tags:
    - OpenSource PR
    - Iceberg
    - Flink
date: "2025-05-27"
thumbnail: "/assets/img/thumbnail/OpenSource_3.png"
bookmark: true
---

# ✏️ 1. 서론
---

이전 포스팅에서 소개한 것처럼, Iceberg Flink Catalog v2.0에서 `MiniClusterWithClientResource` 종속성 제거에 성공했습니다. 이에 따라 해당 이슈의 연장선이자 메인테이너의 요청에 따라, 동일한 변경 사항을 Flink 1.19와 1.20 버전에도 백포팅하기로 했습니다.
(현재 Iceberg는 1.9.1 버전을 사용 중이며, Flink Catalog는 1.19, 1.20, 그리고 2.0 버전을 지원합니다.)

이번 작업은 이전 포스팅인 [📘 Iceberg Flink Catalog v2.0 MiniClusterWithClientResource 종속성 제거](https://jeondaehong.github.io/%F0%9F%96%8A%EF%B8%8F%20%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%20%EA%B8%B0%EC%97%AC/%F0%9F%91%89%20Apache%20Iceberg/1.%20Iceberg%20Flink%20Catalog%20v2.0%20MiniClusterWithClientResource%20%EC%A2%85%EC%86%8D%EC%84%B1%20%EC%A0%9C%EA%B1%B0.html) 의 연장선이자, 유사한 내용이 많아, 비교적 짧게 정리해보려 합니다.

<br>
<br>
<div align="center">◈</div>
<br>

# ✏️ 2. 본론

## ‍💻 2.1. PR: MiniClusterWithClientResource 종속성 제거 Backporting
---

이번 작업 역시 이전 PR의 연장선에 있기 때문에, 이슈 선정 과정에 대한 설명은 생략하였습니다.
따라서 이번 포스팅에서는 곧바로 PR 과정부터 다루겠습니다.

이슈 선정 배경이나 PR 전체 흐름이 궁금하신 분들은 이전 포스팅인 [📘 Iceberg Flink Catalog v2.0 MiniClusterWithClientResource 종속성 제거](https://jeondaehong.github.io/%F0%9F%96%8A%EF%B8%8F%20%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%20%EA%B8%B0%EC%97%AC/%F0%9F%91%89%20Apache%20Iceberg/1.%20Iceberg%20Flink%20Catalog%20v2.0%20MiniClusterWithClientResource%20%EC%A2%85%EC%86%8D%EC%84%B1%20%EC%A0%9C%EA%B1%B0.html) 을 참고해주시기 바랍니다.

### 1️⃣ COMMIT : v1.19 Backporting

기존 2.0의 TestIcebergSourceFailover 클래스와는 크게 다른 부분이 없었습니다. 중간에 구현된 코드가 약간은 다르긴 하였지만, 제가 수정해야하는 범위와는 무관한 부분이었기 때문에 넘어갔습니다.

해당 코드의 이전 버전은 아래와 같았습니다. ( v2.0 과 동일 )

**Before:**
```java
import org.apache.flink.test.util.MiniClusterWithClientResource;
import org.apache.flink.util.function.ThrowingConsumer;

// ...

@Test
public void testBoundedWithTaskManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testBoundedIcebergSource(FailoverType.TM, miniCluster));
}

@Test
public void testBoundedWithJobManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testBoundedIcebergSource(FailoverType.JM, miniCluster));
}
  
// ...

@Test
public void testContinuousWithTaskManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testContinuousIcebergSource(FailoverType.TM, miniCluster));
}

@Test
public void testContinuousWithJobManagerFailover() throws Exception {
    runTestWithNewMiniCluster(
        miniCluster -> testContinuousIcebergSource(FailoverType.JM, miniCluster));
}

// ...

private static void runTestWithNewMiniCluster(ThrowingConsumer<MiniCluster, Exception> testMethod) throws Exception {
    MiniClusterWithClientResource miniCluster = null;
    try {
        miniCluster = new MiniClusterWithClientResource(MINI_CLUSTER_RESOURCE_CONFIG);
	    miniCluster.before();
        testMethod.accept(miniCluster.getMiniCluster());
    } finally {
        if (miniCluster != null) {
          miniCluster.after();
        }
    }
}
```

그래서 아래와 같은 코드로 수정을 동일하게 진행하였습니다.

**After:**
```java
import org.apache.flink.test.junit5.InjectMiniCluster;
import org.junit.jupiter.api.AfterEach;

// ...

@BeforeEach
protected void startMiniCluster(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    if (!miniCluster.isRunning()) {
      miniCluster.start();
    }
}

@AfterEach
protected void stopMiniCluster(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    miniCluster.close();
}

// ...

@Test
public void testBoundedWithTaskManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testBoundedIcebergSource(FailoverType.TM, miniCluster);
}
  
@Test
public void testBoundedWithJobManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testBoundedIcebergSource(FailoverType.JM, miniCluster);
}
  
// ...
  
@Test
public void testContinuousWithTaskManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testContinuousIcebergSource(FailoverType.TM, miniCluster);
}

@Test
public void testContinuousWithJobManagerFailover(@InjectMiniCluster MiniCluster miniCluster) throws Exception {
    testContinuousIcebergSource(FailoverType.JM, miniCluster);
}

```

<br>
### 2️⃣ COMMIT : v1.20 Backporting

**v1.20 백포팅 작업은, v1.19 와 완전 동일하게 진행되었습니다.**

**코드 역시 완전 동일하게 수정하였습니다.**


<br>
> 👉 My PR: [Backporting Removal of MiniClusterWithClientResource from Iceberg Flink Catalog v1.19, v1.20](https://github.com/apache/iceberg/pull/13165)

<br>
<img src="/assets/img/apache-iceberg-contributor.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<img src="/assets/img/apache-iceberg-contributor2.PNG" alt="1" style="border: 2px solid skyblue; border-radius: 4px;" width="100%" />

<br>
### 🍹 중간에 마주한 약간의 이슈

<br>
<br>
<div align="center">◈</div>
<br>


# ✏️ 3. 결론
---

이번 기여를 통해 기술적인 역량뿐만 아니라, 오픈소스 프로젝트에서의 커뮤니케이션의 중요성을 깊이 체감할 수 있었습니다.
단순히 코드를 작성하고 제출하는 것을 넘어, Maintainer 및 다른 기여자들과의 지속적인 소통, 피드백 수용, 그리고 협업 방향 조율이 얼마나 중요한지 직접 경험하게 되었습니다.

특히 이슈를 공유하고, 작업 계획을 명확히 전달하며, 리뷰어의 피드백을 빠르게 반영하는 과정을 통해 오픈소스 생태계의 협업 문화가 신뢰와 효율을 만들어내는 구조임을 배웠습니다.

첫 번째 PR을 통해 긍정적인 피드백을 받은 뒤, Maintainer로부터 요청받았던 Flink 1.20 및 1.19 버전에 대한 backport 작업 역시 빠르게 진행하고 싶다는 동기부여가 생겼고, 기술적 기여뿐 아니라 프로젝트 요구에 신속히 대응하는 태도의 중요성도 느꼈습니다.

또한, 오픈소스 멘토링에서 운영진 역할을 맡아 저의 기여를 하면서 동시에 많은 멘티들이 오픈소스에 도전하는 과정을 지켜보고, 그분들께 답글로 방향성을 제시하는 경험은 저 자신의 성장에도 큰 자극이 되었습니다.
비록 오늘 포스팅에서는 멘토링 내용이 자세히 다뤄지지 않았지만, 저는 앞으로도 이 멘토링 활동과 오픈소스 기여를 꾸준히 이어갈 것이며, 우리나라에 올바르고 건강한 오픈소스 기여 문화가 자리잡도록 노력하는 1세대가 되고자 합니다.

앞으로도 단순한 코드 제공을 넘어, 신뢰를 바탕으로 커뮤니케이션하고, 프로젝트에 실질적인 가치를 더하는 기여자가 되기 위해 꾸준히 노력하겠습니다.
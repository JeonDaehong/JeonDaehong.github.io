---
title: "[#1] 📘 Spring Kafka RetryTopic Bean 이름 변경"
tags:
    - OpenSource PR
    - Spring
    - Kafka
date: "2024-10-09"
thumbnail: "/assets/img/thumbnail/OpenSource_1.png"
bookmark: true
---

# ✏️ 서론
---
개발자로서 오픈소스에 기여하는 일은 언젠가 꼭 해보고 싶은 목표 중 하나였지만, 어디서부터 시작해야 할지 막막한 게 현실이었습니다. 그러던 중, Kafka에 대해 공부하던 어느 날, 문득 Spring Kafka의 내부 구현이 궁금해져 소스코드를 살펴보게 되었고, 자연스럽게 GitHub 저장소까지 들어가게 되었습니다.

그곳에서 열린 이슈들을 둘러보던 중, 비교적 단순해 보이지만 실제로는 사용자에게 혼란을 줄 수 있는 이슈 하나가 눈에 들어왔습니다. 바로 @RetryableTopic에서 사용되는 KafkaTemplate 빈 이름이 공식 문서와 JavaDoc, 그리고 테스트 코드 간에 일관되지 않다는 문제였습니다.

작은 이슈처럼 보일 수 있지만, 이런 부분이 오히려 첫 오픈소스 기여를 시작하기에 가장 적절하다는 생각이 들었습니다. 그렇게 저는 생애 첫 Pull Request를 만들었고, 운 좋게도 머지되어 Spring Kafka의 공식 Contributor가 될 수 있었습니다.

이 글에서는 그 여정을 공유하고, 어떤 문제가 있었는지 그리고 어떻게 기여했는지를 정리해보려 합니다. 오픈소스에 관심은 있지만 막막한 분들에게 작은 계기가 되었으면 합니다.

# ✏️ 본론

## ✏️ 이슈 : KafkaTemplate Bean 이름 불일치
---
Spring Kafka의 공식 문서에서는 `@RetryableTopic` 이 기본적으로 사용할 ***KafkaTemplate*** 빈의 이름을 `defaultRetryTopicKafkaTemplate`라고 명시하고 있습니다. 그러나 실제 `@RetryableTopic` 의 JavaDoc에서는 다음과 같이 설명하고 있었습니다.

```java
* If not specified, a bean with name {@code retryTopicDefaultKafkaTemplate} or {@code kafkaTemplate} will be looked up.
```

즉, JavaDoc에는 retryTopicDefaultKafkaTemplate, **공식 문서에는 defaultRetryTopicKafkaTemplate**라는 이름이 나와 있었고, 테스트 코드 일부도 JavaDoc 쪽 이름을 따라가고 있었습니다. 이로 인해 어떤 빈 이름을 사용해야 하는지 명확하지 않았습니다.

<img src="/assets/img/sping-kafka-issue.PNG" alt="HDFS_write" style="border: 2px solid skyblue; border-radius: 4px;" />
> 👉 Spring Kafka 의 해당 이슈 내용. 이슈 넘버는 #3543.


## ✏️ 기여 1 : JavaDoc 정정
---
먼저, `RetryableTopic` 어노테이션 클래스의 JavaDoc 주석을 다음과 같이 수정했습니다.

**Before:**
```java
 * The bean name of the {@link org.springframework.kafka.core.KafkaTemplate} bean that
 * will be used to forward the message to the retry and Dlt topics. If not specified,
 * a bean with name {@code retryTopicDefaultKafkaTemplate} or {@code kafkaTemplate}
 * will be looked up.
 *
 * @return the kafkaTemplate bean name.
```

**After:**
```java
 * The bean name of the {@link org.springframework.kafka.core.KafkaTemplate} bean that
 * will be used to forward the message to the retry and Dlt topics. If not specified,
 * a bean with name {@code defaultRetryTopicKafkaTemplate} or {@code kafkaTemplate}
 * will be looked up.
 *
 * @return the kafkaTemplate bean name.
```

bean 으로 retryTopicDefaultKafkaTemplate 대신 defaultRetryTopicKafkaTemplate 사용한다고 수정을 하였습니다.

이로써 공식 문서와 JavaDoc이 일치하게 되었고, 사용자 혼란을 줄일 수 있게 되었습니다.

> 👉 **Fix: Replace retryTopicDefaultKafkaTemplate with defaultRetryTopicKafkaTemplate in docs**


## ✏️ 기여 2 : 테스트 코드 정정
---
또한 테스트 코드 내에서도 잘못된 빈 이름 문자열을 직접 명시하고 있었습니다. `RetryTopicConfigurationProviderTests` 라는 테스트 클래스에서 사용 중이었는데, 이 부분은 상수 `RetryTopicBeanNames.DEFAULT_KAFKA_TEMPLATE_BEAN_NAME` 을 사용하도록 리팩터링했습니다.


**Before:**
```java
@Test
void shouldProvideFromAnnotation() {

	// setup
	willReturn(kafkaOperations).given(beanFactory).getBean("retryTopicDefaultKafkaTemplate", KafkaOperations.class);

	// given
	RetryTopicConfigurationProvider provider = new RetryTopicConfigurationProvider(beanFactory);
	RetryTopicConfiguration configuration = provider.findRetryConfigurationFor(topics, annotatedMethod, bean);
	RetryTopicConfiguration configurationFromClass = provider
			.findRetryConfigurationFor(topics, null, AnnotatedClass.class, bean);
	// then
	then(this.beanFactory).should(times(0)).getBeansOfType(RetryTopicConfiguration.class);
	assertThat(configuration).isNotNull();
	assertThat(configurationFromClass).isNotNull();
}

@Test
void shouldProvideFromMetaAnnotation() {

	// setup
	willReturn(kafkaOperations).given(beanFactory).getBean("retryTopicDefaultKafkaTemplate", KafkaOperations.class);

	// given
	RetryTopicConfigurationProvider provider = new RetryTopicConfigurationProvider(beanFactory);
	RetryTopicConfiguration configuration = provider.findRetryConfigurationFor(topics, metaAnnotatedMethod, bean);
	RetryTopicConfiguration configurationFromClass = provider
			.findRetryConfigurationFor(topics, null, MetaAnnotatedClass.class, bean);
	// then
	then(this.beanFactory).should(times(0)).getBeansOfType(RetryTopicConfiguration.class);
	assertThat(configuration).isNotNull();
	assertThat(configuration.getConcurrency()).isEqualTo(3);
	assertThat(configurationFromClass).isNotNull();
	assertThat(configurationFromClass.getConcurrency()).isEqualTo(3);
}
```

**After:**
```java
@Test
void shouldProvideFromAnnotation() {

	// setup
	willReturn(kafkaOperations).given(beanFactory).getBean(RetryTopicBeanNames.DEFAULT_KAFKA_TEMPLATE_BEAN_NAME, KafkaOperations.class);

	// given
	RetryTopicConfigurationProvider provider = new RetryTopicConfigurationProvider(beanFactory);
	RetryTopicConfiguration configuration = provider.findRetryConfigurationFor(topics, annotatedMethod, bean);
	RetryTopicConfiguration configurationFromClass = provider
			.findRetryConfigurationFor(topics, null, AnnotatedClass.class, bean);
	// then
	then(this.beanFactory).should(times(0)).getBeansOfType(RetryTopicConfiguration.class);
	assertThat(configuration).isNotNull();
	assertThat(configurationFromClass).isNotNull();
}

@Test
void shouldProvideFromMetaAnnotation() {

	// setup
	willReturn(kafkaOperations).given(beanFactory).getBean(RetryTopicBeanNames.DEFAULT_KAFKA_TEMPLATE_BEAN_NAME, KafkaOperations.class);

	// given
	RetryTopicConfigurationProvider provider = new RetryTopicConfigurationProvider(beanFactory);
	RetryTopicConfiguration configuration = provider.findRetryConfigurationFor(topics, metaAnnotatedMethod, bean);
	RetryTopicConfiguration configurationFromClass = provider
			.findRetryConfigurationFor(topics, null, MetaAnnotatedClass.class, bean);
	// then
	then(this.beanFactory).should(times(0)).getBeansOfType(RetryTopicConfiguration.class);
	assertThat(configuration).isNotNull();
	assertThat(configuration.getConcurrency()).isEqualTo(3);
	assertThat(configurationFromClass).isNotNull();
	assertThat(configurationFromClass.getConcurrency()).isEqualTo(3);
}
```

`"retryTopicDefaultKafkaTemplate"` 으로 되어있던 Bean 이름 부분을 `RetryTopicBeanNames.DEFAULT_KAFKA_TEMPLATE_BEAN_NAME` 로 변경하였습니다.

이를 통해 빈 이름도 변경하였고, 하드코딩된 문자열을 제거하면서, 상수를 사용하는 방식으로 코드의 일관성과 안정성을 확보했습니다. 추후 KafkaTemplate 빈 이름이 변경되더라도 상수만 수정하면 되므로 유지보수가 용이해졌습니다.

> 👉 **Fix: Replace retryTopicDefaultKafkaTemplate with RetryTopicBeanNames.DEFAULT_KAFKA_TEMPLATE_BEAN_NAME in Test Code**


# ✏️ 결론 ( 그리고, 재밌었던 경험 )
---
이번 기여를 통해 Spring Kafka 오픈소스의 문서와 테스트 코드의 불일치 문제를 해결하고, 더 일관되고 유지보수하기 쉬운 코드 기반을 마련했습니다.


이번 과정을 겪는 중에는, 재밌는 일이 하나 있었습니다.

## ✏ Apache Oak 기여 실패와, 오픈 소스 기여의 생태계
---
Spring Kafka 를 기여하기 전에, Apache Jackrabbit Oak 의 이슈를 하나 찾을 수 있었습니다.

이 역시 쉬운 이슈였기 때문에, 기여를 도전해보고자 하였습니다.

당시 이슈 내용은 다음과 같았는데

`MAX_SEGMENT_SIZE` 상수가 Segment와 SegmentDataUtil s에 중복 정의되어 있으니 하나로 공유 할 수 있게 해달라는 내용이었습니다.

**Segment** 라는 클래스에서 `static final int MAX_SEGMENT_SIZE = 1 << 18;` 로 되어있는 부분에 `public` 을 달아주고, 그걸 **SegmentDataUtil** 에서 사용 할 수 있게 해주는게 전부였습니다.

하지만 결과는 Merge 실패였습니다.

이유는 간단했는데, 이미 저보다 먼저 해당 이슈를 캐치하고 PR 을 올린 사람이 있었기 때문이었습니다.

오픈 소스 생태계를 보면, 처음에는 잘 몰라서 실수 할 수 있는 2가지가 있습니다. 하나는 완료 된 이슈인데도 이슈가 Close 되어있지 않은게 있을 수 있다는 것입니다.

또 다른 하나는 누군가 해당 이슈를 해결하기 위해 Assign 을 받았는데, 그것을 가로채는 행동을 해서는 안된다는 것입니다.

보통은 이슈에 댓글로 본인이 해결하겠다고 리플을 달아두고 진행을 합니다. 그렇기 때문에, 어떠한 이슈를 해결하고자 한다면, 꼭 댓글에 본인이 해결하겠다는 의사를 밝히고, 진행하는 것이 좋습니다.

그리고 다른 사람이 진행을 하겠다고 댓글을 이미 남긴 상태라면, 그걸 가로채서는 안됩니다. 다만, 댓글이 달리고 한참이 지났는데도 해결이 되지 않은 이슈라면, 해당 이슈가 현재 해결 중인지, 그게 아니라면 내가 해결을 해도 되는지 댓글로 물어보고 진행을 하는 방향도 있습니다.
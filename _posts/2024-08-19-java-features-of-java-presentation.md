---
title: Java OOP, SOLID Deep Dive Presentation
author: daehong
date: 2024-08-19 22:00:00 +0800
categories: [IT Presentation, Company]
tags: [Java, Presentation, Features of Java, Company, Conference]
render_with_liquid: false
pin: true
image:
  path: /assets/img/thumbnail/oop-java-presentation.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Features of Java Deep Dive Presentation
---

2024년 8월 회사에서 가벼운 **컨퍼런스**가 있었다.

그리고 필자도 주니어 개발자로서, Java에 대한 발표를 해야했다.

동일 동등에 대한 발표, String에 대한 발표, JVM에 대한 발표 등등 여러가지가 있을 수 있지만,
필자는 자바의 기본이자 기둥이 되는, 객체지향과 SOLID 에 대해서 발표하기로 하였다.

그 이유는 **객체지향 프로그래밍은 자바의 뿌리이자, 근간이 되는 자바의 핵심 요소**이기 때문이다.

그러나 코드 구현을 먼저 배워온 개발자들에게는 왜 이렇게 개발해야 되는지도 모른 채 그저 학교나 학원에서 배운대로 객체지향 언어를 사용하고,

객체지향적인 방법으로 구현만 할 줄 아는 상태로 연차만 쌓여가는 경우들이 종종 있었다.

**지피지기면 백전백승**이라는 말이 있듯, 개발자들이 보다 자바를 깊게 이해하고, 좋은 설계를 하고, 좋은 개발을 하기 위해서는 객체지향이 무엇인지를 알아야 된다고 생각했고,

그만큼 이 부분이 자바의 가장 중요한 요소라고 생각했기 때문에 선택하게 되었다.

그것이 내가 발표 주제로 **객체지향**을 선택한 이유이다.

그래서 먼저 자바의 등장 배경으로 시작해서 객체지향 프로그래밍이란 무엇인지, 그리고 **객체지향의 특징 4가지**를 설명하고,

마지막으로 **객체지향 프로그래밍을 보다 견고하게 설계하기 위한 이정표가 되어주는 SOLID**까지 알아보도록 하겠다.

<br>

### ✏️ 자바의 등장 배경
---

**먼저 자바의 등장 배경을 간단히 알아보겠다.**

![image](https://github.com/user-attachments/assets/15cf4e7e-16c7-4242-9dcc-eb5db8f8a0a5)

자바는 C와 C++의 문제점을 개선하기 위해 제임스 고슬링(James Gosling)이라는 사람이 패트릭(Patrick), 노튼(Naughton)과 함께 개발하였다.

여기서 중점적으로 해결하려 하였던 C, C++의 문제점은 **메모리를 개발자가 직접 제어해야 한다는 문제, 절차지향형 코드이기에 복잡성이 높아 개발자가 오류를 만들어내기 쉽다는 문제, 그리고 플랫폼에 따라 다른 결과를 출력할 수 있다는 문제**가 있다.

그래서 제임스 고슬링은 자바라는 프로그래밍 언어를 개발할 때, **GC를 통한 자동 메모리 관리와, JVM을 통한 독립적인 플랫폼 사용, 그리고 객체지향 프로그래밍 방법을 통한 복잡성 감소**에 중점을 두었다.

<br>

### ✏️ 절차지향 vs 객체지향
---

![image](https://github.com/user-attachments/assets/9fc67b1b-06b4-49f6-893f-72d14cebeb4e)

그럼 절차지향이라는 것은 무엇이길래 복잡성이 높고, 객체지향이라는 것은 무엇이길래 복잡성을 낮출 수 있는 것일까?

절차지향 프로그래밍이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.

대표적인 절차지향 언어에는 C언어가 있다.

이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리하다.

그러나 코드가 한 곳에 모여있어 복잡도가 높아 유지보수가 어렵다는 단점이 있고, 실행 순서가 정해져있기 때문에 코드의 순서가 바뀌면 동일한 결과를 보장할 수 없다는 문제와, 그 만큼 디버깅이 어렵다는 많은 단점들이 있다.

이러한 문제를 해결하기 위해 등장한 것이 **객체지향 프로그래밍** 방법이다.

객체지향 프로그래밍은 실제 세계를 모델링하여 소프트웨어를 개발하는 방법이다.

객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각하게 된다.

이는 마치 컴퓨터 부품을 하나씩 사다가 컴퓨터를 조립하는 것과 같은 방법이다.

그렇기 때문에 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 같은 기능을 중복으로 연산하지 않거나 모듈을 재활용하기 때문에 유지보수에 유리하다.

**그럼 절차지향의 반댓말은 객체지향이 되는 것일까?**

객체지향의 반대는 절차지향이 아니고 절차지향의 반대는 객체지향이 아니다.

앞에 설명한 것처럼 절차지향은 순차적으로 실행에 초점이 되어 있고 객체지향은 객체간의 관계/조직에 초점을 두고 있다.

이렇게 설명하면 객체지향은 절차적으로 실행되지 않냐? 라는 의문이 들수 있는데, 객체지향 역시 따지고 보면 절차지향과 동일한 순서로 실행된다.

다르게 이야기하면, C와 같은 언어를 사용해도 포인터 등을 수동적으로 활용하여 객체 지향적으로 코딩을 할 수는 있고, 자바나 C# 등을 이용하여서도 절차지향적으로 프로그래밍을 할 수는 있다. 

핵심은 데이터 중심이 아닌 기능 중심으로 구현하는 것이며, 해당 언어가 그것을 얼마나 편리하게 구현할 수 있도록 도와주는지가 관건이다.

즉, 여러 함수가 데이터를 공유하는 방식이 아니라 특정 함수가 다른 함수를 사용하는 방식으로 구현을 하고, 데이터 공유를 적절히 제한하느냐가 객체지향 프로그래밍의 중심이 된다고 볼 수 있다.

![image](https://github.com/user-attachments/assets/82081273-3114-40e0-b0af-f56525c7545d)

<br>

### ✏️ 객체지향이란?
---

**그러면 자바의 가장 중요한 핵심 중 하나인, 그 객체지향에 대해 좀 더 자세히 들여다보겠다.**

**객체 지향 프로그래밍(Object-Oriented Programming, OOP)**이란 컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 **여러 독립적인 부품들의 조합,** **즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임**을 의미한다.

마치 자동차를 만든다고 했을 때, 수많은 부품들의 결합과 연결로 하나의 완전한 자동차가 만들어지는 것과 같다고 할 수 있다. 객체 지향적으로 소프트웨어를 설계한다는 말의 의미는 어떤 프로그램의 일부분에 해당하는 작은 부품, 즉 객체를 먼저 만들고 이렇게 만들어진 여러 객체들을 조립해서 하나의 완성된 프로그램을 만드는 프로그래밍 방법론을 뜻한다. 여기서 각 부품에 해당하는 객체에 대해서는 아래에서 좀 더 자세히 알아보도록 하겠다.

이제 하나씩 살펴보겠지만, 이렇게 객체 지향적으로 프로그램을 설계하는 데에는 여러 이점들이 있다. 가장 큰 이점 중 하나는 객체 지향적 설계를 통해서 **프로그램을 보다 유연하고 변경이 용이하게 만들 수 있다는 점**이다. 마치 컴퓨터 부품을 갈아 끼울 때, 해당하는 부품만 쉽게 교체하고 나머지 부품들을 건드리지 않아도 되는 것처럼, 소프트웨어를 설계할 때 객체 지향적 원리를 잘 적용해 둔 프로그램은 각각의 부품들이 각자의 독립적인 역할을 가지기 때문에 **코드의 변경을 최소화하고 유지보수를 하는 데 유리**하다.

더 나아가, **코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현**할 수 있다. 또한 객체 지향 프로그래밍은 실제 우리가 보고 경험하는 세계를 최대한 프로그램 설계에 반영하기 위한 지속적인 노력을 통해 발전해왔기 때문에, 보다 **인간 친화적이고 직관적인 코드**를 작성하기에 용이하다.

**객체 지향 프로그래밍의 4가지 특징**은 각각 **추상화, 상속, 다형성, 캡슐화**인데, 모두 이러한 객체 지향적 설계의 이점들을 가장 잘 살릴 수 있는 방향으로 발전되어 왔다고 할 수 있다.

![image](https://github.com/user-attachments/assets/afd66c17-7357-46ae-8e39-47f027ae6856)

이러한 맥락에서, 지금부터 객체 지향 프로그래밍의 가장 기본적인 단위이자 시작 점이 되는 객체 개념과 더불어 각 특징들의 내용을 살펴보면서 각 특징이 어떻게 객체 지향적 설계를 하는 데 도움을 줄 수 있는지 이해해보도록 하겠다.

그럼 아까부터 언급되었던 **객체**란 대체 무엇일까? 앞서 언급한 것처럼, **객체**는 **객체 지향 프로그래밍의 가장 기본적인 단위이자 시작 점**이라 할 수 있다. 객체 지향 개념의 가장 기본적인 전제는 실제 세계는 객체들로 구성되어 있으며, 보여지는 모든 현상과 발생하는 모든 사건은 이러한 **객체들 간의 상호작용**을 통해 발생한다는 것에서 출발한다.

잠시 컴퓨터에서 눈을 돌려 주위를 살펴보자. 무엇이 보이는가? 각자 위치한 장소에 따라 다른 여러 사물과 사람이 보일 것이다. 책상, 의자, 시계, 전등, 책 등 우리가 주변에서 흔히 볼 수 있는 **“모든 실재하는 대상”**을 객체 지향 프로그래밍 언어에서는 **객체**라고 부른다.

사실 객체의 범주에는 우리 눈에 보이는 유형의 대상뿐만 아니라 눈에 보이지 않는 어떤 논리, 사상, 철학, 개념, 공식 등과 같은 무형의 대상들도 포함될 수 있다. 한 마디로, 객체는 **우리가 보고 느끼고 인지할 수 있는 그 모든** **것**을 의미한다고 할 수 있다.

객체 지향 프로그래밍에서는 이와 같은 각각의 객체를 추상화시켜 **속성**과 **기능**으로 분류한 후에 이것을 다시 각각 **변수(variable)와 함수(function, method)**로 정의하고 있다.

![image](https://github.com/user-attachments/assets/91eb310e-f1a5-4d10-ae52-b29275d2c7a8)

그러면 이제부터 본격적으로 객체 지향의 4가지 특징을 각각 살펴보면서, 각각의 특징들이 앞서 설명한 객체 지향적 설계에 어떻게 녹여지고 반영되어 있는 지 확인해보도록 하겠다.

<br>

### ✏️ 캡슐화

![image](https://github.com/user-attachments/assets/e0e066e1-0dab-489f-8eaf-829d8d558051)

**먼저 캡슐화이다.**

캡슐화란 클래스 안에 **서로 연관 있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하고, 은닉하는 것**을 말한다.

캡슐화를 구현하는 방법으로는 접근제어자를 활용하는 방법과, Getter/Setter 메서드를 활용하여 구현하는 방법 두 가지가 있으며, 둘을 잘 결합하여 구현해야 한다.

예를 들면, 클래스의 멤버 변수를 private로 선언하고, 이를 조작하기 위한 Getter/Setter 메서드를 public으로 구현하는 것이다. 그렇게 하면, 해당 메서드를 거치지 않고, 의도하지 않은 곳에서 멤버 변수에 접근하는 것을 막을 수 있게 된다. 이것이 데이터를 외부로부터 보호하고 은닉하는 것이라고 할 수 있겠다.

또한, 단순히 Getter/Setter를 통하여 접근, 수정을 할 수 있게 한다고만 해서 캡슐화의 전부라고 할 수는 없다. 나는 개인적으로 개발자가 설계한 클래스의 의도를 벗어나지 않는 범위에서 데이터에 접근하거나, 그 데이터를 수정할 수 있게 하는 것이 캡슐화의 더 중요한 핵심이라고 생각한다.

아래 코드는 그 예시 코드이다.

![image](https://github.com/user-attachments/assets/55ce2894-819f-4571-b662-3d24899286c5)

Getter/Setter 함수는 기본적으로 어떻게 구현되어 있는지 알 것이기에, Lombok의 어노테이션을 사용하여 간략하게 만들었다.

먼저 개발자Dto는 기본적인 캡슐화를 구현하고 있다. private 접근제어자로 멤버 변수를 선언하고, Getter, Setter로 제어한다.

그러나 이번에 농협은행에서 진행하는 프로젝트에는 경력 3년 이상의 개발자만 참여가 가능하다고 한다. 그래서 농협은행 프로젝트 개발자Dto는, 3년 이상의 경력이 있는 개발자만 입력할 수 있게 제한을 걸어두었다.

![image](https://github.com/user-attachments/assets/7c553462-fd94-4b73-9a05-9ed1cb12a5e3)

이때 만약, 2년 경력밖에 없는 ‘대홍’이라는 개발자를 투입하려 한다면, 예외가 발생하게 된다. 이렇게 개발자의 의도 안에서만 클래스를 입력, 수정할 수 있게 하는 것이 캡슐화의 핵심이라고 할 수 있겠다.

또 다른 예시로는 어떤 클래스에 몇 월 며칠을 String 타입으로 받아야 하는 경우가 있다고 가정한다면, 몇 월에 해당하는 값은 1 ~ 12를 벗어날 수 없도록 구현할 수 있을 것 같다.

<br>

### ✏️ 상속

![image](https://github.com/user-attachments/assets/d1736e9e-7102-4555-913b-1a405c947e6b)

**다음은 상속이다.**

상속은 **기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소**를 의미한다.

상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 **상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용**할 수 있도록 한다.

즉, 클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 **재사용**할 수 있어 **반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근**하여 사용할 수 있도록 한다.
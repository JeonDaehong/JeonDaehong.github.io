---
title: Apache ZooKeeper Introduction
author: daehong
date: 2024-07-28 20:55:00 +0800
categories: [Personal IT Study, Apache Zookeeper]
tags: [Zookeeper, DistributedSystems, HighAvailability, OpenSource, JavaAPI]
render_with_liquid: false
pin: true
image:
  path: /assets/img/thumbnail/Apache_ZooKeeper_logo.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Apache ZooKeeper Introduction
---

## ✏️ 주키퍼를 왜 사용해야 할까?
---
분산 시스템을 운영하다 보면 여러 노드 간에 정보를 어떻게 공유하고, 클러스터 내 서버들의 상태를 어떻게 체크하며,
분산된 서버들 간의 동기화를 위해 Lock을 어떻게 처리할 것인지와 같은 문제들이 발생합니다.
특히 다수의 노드에서 수행되는 분산 처리 애플리케이션은 단일 노드에서 수행되는 애플리케이션보다 고려해야 할 요소가 많으며,
그 중에서도 `부분 실패(Partial Failure)`가 가장 큰 문제입니다.
네트워크를 통해 메시지가 전송되는 도중 네트워크가 끊기면 송신자는 수신자가 메시지를 성공적으로 수신했는지조차 알 수 없습니다.
이러한 부분 실패를 안전하게 처리하기 위해 주키퍼는 분산 처리 도구를 제공합니다.
특히 `Kafka나 HBase(NoSQL)와 같은 분산 솔루션`에서 많이 사용됩니다.
분산 시스템을 조정하기 위해서는 데이터 접근이 빨라야 하고, 장애 대응이 가능해야 하는데, 주키퍼는 이를 가능하게 합니다.

<br>

## ✏️ 주키퍼의 특징
---
주키퍼는 크게 세 가지 특징을 가지고 있습니다.

- **클러스터링:** 주키퍼는 홀수로 구성된 클러스터로 구성되며, 클러스터의 과반수 이상이 정상적으로 동작하면 주키퍼는 정상적으로 작동합니다.

- **데이터베이스:** 주키퍼는 Key-Value 기반의 DB를 제공하며, 이를 사용하여 분산 시스템의 구성, 동기화, 상태 관리를 수행합니다.

- **복제:** 주키퍼는 DB의 모든 데이터를 복제합니다. 따라서 일부 서버에 문제가 생겨도 데이터의 손실 없이 시스템을 유지할 수 있습니다.

<br>

## ✏️ 주키퍼의 장점
---
주키퍼는 클러스터링 기능을 자체적으로 지원하며, 매우 쉽게 적용할 수 있습니다. 주키퍼를 사용하면 다음과 같은 이점을 얻을 수 있습니다.

- **설정 관리:** 클러스터의 설정 정보를 최신으로 유지하기 위한 시스템입니다.

- **클러스터 관리:** 클러스터의 서버가 추가되거나 제외될 때, 그 정보를 클러스터 내 서버들이 공유하기 위한 시스템입니다.

- **리더 선출:** 다중 애플리케이션 중 어떤 노드를 리더로 선출할지 정하는 로직을 만듭니다.

- **락, 동기화:** 클러스터에서 쓰기 연산이 빈번할 경우 클러스터 전체를 동기화를 통해 데이터 불일치를 방지합니다.

<br>

## ✏️ 주키퍼의 단점
---
주키퍼를 사용하면 학습에 시간이 적지 않게 소요됩니다. 또한 주키퍼 사용으로 인한 추가 리소스가 필요하며, 주키퍼를 운영함에 따라 서비스 관리의 복잡성도 증가합니다.

<br>

## ✏️ 주키퍼의 구조
---

- **Request Processor:** Write 요청을 처리합니다.

- **Zab (Zookeeper Atomic Broadcast Protocol):** Request Processor에서 처리한 요청을 트랜잭션으로 생성하여 모든 서버에 전파합니다. 이 과정은 [Leader-Propose] -> [Follower-Accept] -> [Leader-Commit] 단계로 구성됩니다.

- **In-memory DB:** Znode의 정보가 저장되며, 로컬 파일시스템에 복제를 구성할 수 있습니다.

<br>

## ✏️ 주키퍼 사용 예시
---
예를 들어, Client(Kafka)가 어떤 설정값 혹은 메타데이터를 주키퍼에 쓸 때 다음과 같이 동작합니다.

1. 특정 서버에 접속하여 서버 데이터 업데이트

2. 해당 서버는 Leader 서버에 데이터가 업데이트 되었음을 전송

3. Leader 서버는 업데이트 신호를 받고, 다른 Follower 서버들에게 브로드캐스트(Broadcast) 형식으로 전송

4. 나머지 Follower 서버들도 데이터 업데이트

위 4가지 과정을 통해 주키퍼는 데이터를 항상 일관성 있게 유지합니다.
카프카는 메시지를 주고받는 Pub/Sub 외에는 아무것도 하지 않는 분산 처리 플랫폼입니다.
따라서 브로커 상태를 저장하지 않기 때문에 상태 관리를 위해서 주키퍼를 사용합니다.
이때 Producer와 Consumer는 카프카의 브로커 정보를 가지고 있습니다.
만약 동적으로 브로커의 상태가 변경(스케일 아웃 등)되는 경우 이를 주키퍼가 Producer와 Consumer에게 알려줍니다.
일반적으로 카프카 메시지 브로커와 Zookeeper는 1:1로 구성되며,
만약 Producer가 특정 카프카 브로커로 메시지를 생산할 때
이를 실패하면 주키퍼가 다른 정상 서버로 Producer와, Consumer에게 브로커를 알리는 방식으로 운영됩니다.

<br>

## ✏️ 주키퍼와 카프카의 관계
---
주키퍼(Apache ZooKeeper)와 카프카(Apache Kafka)는 분산 시스템 환경에서 밀접하게 연관된 두 가지 기술입니다.
주키퍼는 카프카의 안정성과 신뢰성을 보장하는 데 중요한 역할을 합니다

1. **메타데이터 관리:**

	- **브로커 메타데이터:** 카프카 클러스터에서 브로커가 추가되거나 제거될 때, 주키퍼는 클러스터의 현재 상태를 기록하고 유지합니다. 각 브로커는 주키퍼에 자신이 활성 상태임을 주기적으로 알립니다.

	- **주키퍼가 브로커 정보를 제공:** 카프카 클러스터의 모든 브로커는 주키퍼를 통해 자신의 존재와 상태를 클러스터에 알리며, 주키퍼는 이러한 정보를 다른 브로커와 클라이언트에게 제공합니다.

2. **리더 선출:**

	- **파티션 리더 선출:** 카프카에서는 각 파티션마다 리더 브로커가 존재합니다. 리더 브로커는 해당 파티션에 대한 모든 읽기 및 쓰기 요청을 처리합니다. 주키퍼는 이 리더를 선출하고, 리더 브로커의 상태를 추적합니다.

	- **리더 선출 프로세스:** 만약 현재 리더가 실패하면, 주키퍼는 새로운 리더를 선출합니다. 이를 통해 카프카 클러스터의 고가용성과 안정성이 보장됩니다.

3. **컨슈머 오프셋 관리:**

	- **오프셋 저장:** 과거에는 주키퍼가 각 컨슈머의 오프셋(컨슈머가 마지막으로 읽은 메시지 위치)을 저장하고 관리했습니다. 이를 통해 컨슈머가 재시작될 때 마지막으로 읽은 위치를 주키퍼에서 조회하여 다시 시작할 수 있었습니다.

	- **카프카 내부 저장:** 최근 버전의 카프카에서는 오프셋 저장을 주키퍼가 아닌 카프카 자체에 저장하도록 변경되었습니다. 이는 주키퍼의 부하를 줄이고, 카프카의 성능을 향상시키기 위함입니다.

4. **클러스터 구성 관리:**

	- **브로커 추가 및 제거:** 카프카 클러스터에 브로커가 추가되거나 제거될 때 주키퍼는 이를 감지하고, 클러스터 구성 정보를 업데이트합니다. 이를 통해 새로운 브로커를 포함한 최신 클러스터 정보를 클러스터 내 모든 구성원이 알 수 있게 됩니다.

	- **토픽 및 파티션 정보:** 주키퍼는 카프카의 토픽과 파티션 구성 정보를 저장합니다. 이를 통해 브로커와 컨슈머는 최신 토픽 및 파티션 상태를 쉽게 조회할 수 있습니다.

5. **헬스 체크 및 장애 조치:**

	- **헬스 체크:** 주키퍼는 주기적으로 카프카 브로커들의 상태를 체크합니다. 브로커가 비정상적으로 동작하면 이를 감지하고 클러스터 구성원들에게 알립니다.

	- **장애 조치:** 브로커가 실패하면, 주키퍼는 이를 다른 브로커들에게 알리고, 리더 브로커를 재선출하거나 필요한 장애 조치를 수행합니다.


즉, 주키퍼는 카프카 클러스터의 안정성과 고가용성을 보장하는 데 필수적인 역할을 합니다.
카프카는 주키퍼를 통해 브로커와 파티션의 메타데이터를 관리하고, 리더 선출 및 장애 조치 등을 수행합니다.
주키퍼와 카프카의 이러한 협력 관계는 카프카가 대규모 분산 환경에서도 안정적으로 운영될 수 있도록 지원합니다.

![image](https://github.com/user-attachments/assets/342ee679-4288-41fa-9d24-5bdd23d2b1d0)